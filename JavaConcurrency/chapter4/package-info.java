/**
 * 第4章 Java并发编程基础
 * 4.1 线程简介
 * 4.1.2 为什么使用多线程：
 *  1）更多的处理器核心   2）更快的响应时间   3）更好的编程模式
 * 4.1.3 线程优先级
 *  1）线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。
 * 4.1.4 线程的状态
 *  1）6种状态：New（初始），Runnable（包括就绪和运行），Blocked（阻塞），Waiting（等待），Time_waiting（超时等待），Terminated（终止）
 *  2）Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，
 *  但是阻塞在java.concurrent包中Lock接口的线程状态确是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。
 * 4.1.5 Daemon线程
 *  1）主要用作程序中后台调度以及支持性工作。当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。
 *  2）Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。
 *  3）在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。
 *
 * 4.2 启动和终止线程
 * 4.2.1 构造线程
 * 4.2.2 启动线程
 *  1）启动一个线程前，最好为这个线程设置线程名称。
 * 4.2.3 理解中断
 *  1）线程通过方法isInterrupted()检查自身是否被中断来进行响应。
 * 4.2.4 过期的suspend()、resume()、stop()
 *  1）不建议使用，因为suspend()方法在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。
 *  2）stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。
 *
 *
 * 4.3 线程间通信
 * 4.3.1 volatile和synchronized关键字
 *  1）关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，
 *  它能保证所有线程对变量访问的可见性。
 *  2）关键字synchronize可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，它保证了
 *  线程对变量访问的可见性和排他性。同一时刻只能有一个线程获取到由synchronized所保护对象的监视器monitor。
 *  3）对象、监视器、同步队列和执行线程之间的关系：任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，
 *  线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对
 *  监视器的获取。
 * 4.3.2 等待/通知机制
 *  1）等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上。
 *  2）等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另外一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知
 *  后从对象O的wait()方法返回，进而执行后序操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，
 *  用来完成等待方和通知方之间的交互工作。
 *  3）例子WaitNotify说明了:
 *      1）使用wait()/notify()/notifyAll()时需要先对调用对象加锁。
 *      2）调用wait()方法后，线程状态由Running变成Waiting，并将当前线程放置到对象的等待队列。
 *      3）notify()/notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()/notifyAll()的线程释放锁之后，
 *      等待线程才有机会从wait()返回。
 *      4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程
 *      全部移出到同步队列，被移出的线程状态由Waiting变成Blocked。
 *      5）从wait()方法返回的前提是获得了调用对象的锁。
 *  4.3.3 等待/通知的经典范式
 *   1）分为两部分，分别针对等待反（消费者）和通知方（生产者）
 *   2）等待方遵守如下原则：
 *      1）获取对象的锁。
 *      2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。
 *      3）条件满足则执行对应的逻辑。
 *      对应的伪代码如下。
 *      synchronized(对象){
 *          while(条件不满足) {
 *              对象.wait();
 *          }
 *          对应的处理逻辑
 *      }
 *   3）通知方遵守如下规则。
 *      1）获得对象的锁。
 *      2）改变条件。
 *      3）通知所有等待在对象上的线程。
 *      对应的伪代码如下。
 *      synchronized(对象) {
 *          改变条件
 *          对象.notifyAll();
 *      }
 *  4.3.4 管道输入/输出流
 *
 * @author 郑元浩
 */
package chapter4;