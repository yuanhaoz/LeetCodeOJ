/**
 * 第2章  Java并发机制的底层实现原理
 * 1. volatile的应用
 * 1.1 volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是
 * 当一个线程修改一个共享变量时，另外一个线程可以读到这个修改的值。
 * 如果一个字段被声明为volatile，Java线程内存模型确保看到这个变量的值是一致的。
 * 1.2 volatile的两条实现原则：
 * （1）Lock前缀指令会引起处理器缓存会写到内存中
 * （2）一个处理器的缓存会写到内存会导致其他处理器的缓存无效。
 * 1.3 volatile的使用优化
 * （1）追加字节码能优化性能
 * （2）追加64字节能够提升并发编程的效率
 * （3）下面两种场景中可以在使用volatile变量时可以不用追加到64字节：
 * 3.1）缓存行非64字节宽的处理器
 * 3.2）共享变量不会被频繁地写
 * <p>
 * 2. synchronized的实现原理与应用
 * 2.1 利用Synchronized实现同步的基础是Java中的每一个对象都可以作为锁。具体表现为以下3种形式：
 * 1）对于普通同步方法，锁是当前实例对象；
 * 2）对于静态同步方法，锁是当前类的Class对象
 * 3）对于同步方法块，锁是Synchronized括号里配置的对象。
 * 2.2 synchronized 用的锁是存在Java对象头里的。Java对象头里的 Mark Word 里默认存储对象的 HashCode、
 * 分代年龄和锁标记位。在运行期间，Mark Word 里存储的数据会随着锁标志位的变化而变化。
 * 2.3 Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中
 * 锁共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态
 * 会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。
 * 1）偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入偏向锁。
 * 当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要
 * 进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。
 * 2）轻量级锁：
 * 轻量级加锁：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到
 * 锁记录中，官方称 Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前
 * 线程获得锁，如果失败，表示其他线程竞争锁，当前线程变尝试使用自旋获得锁。
 * 轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，表示没有竞争发生。
 * 如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
 * 2.4 锁的优缺点对比
 * 1）偏向锁：
 * 优点：加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距。
 * 缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗
 * 适用场景：适用于只有一个线程访问同步块场景
 * 2）轻量级锁：
 * 优点：竞争的线程不会阻塞，提高了程序的响应速度
 * 缺点：如果始终得不到锁竞争的线程，使用自旋锁会消耗CPU
 * 适用场景：追求响应时间，同步块执行速度非常快
 * 3）重量级锁：
 * 优点：线程竞争不使用自旋，不会消耗CPU
 * 缺点：线程阻塞，响应时间缓慢
 * 适用场景：追求吞吐量，同步块执行速度较长
 * <p>
 * 3.原子操作的实现原理
 * 3.1 术语定义：
 * 1）原子操作是指不可被中断的一个或一系列操作。
 * 2）CAS(比较并交换)：CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，
 * 如果没有发生变化，才交换成新值，发生了变化则不交换
 * 3）CPU流水线和内存顺序冲突
 * 3.2 处理器如何实现原子操作：缓存加锁 或 总线加锁
 * 1）使用总线锁保证原子性：所谓总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求
 * 将被阻塞住，那么该处理器可以独占共享内存。
 * 2）使用缓存锁保证原子性：在同一时刻，我们只需要保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，
 * 这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。缓存锁定是指内存区域如果 被缓存在处理器的
 * 缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言Lock #信号，而是修改内部的内存地址，
 * 并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，但其他处理器
 * 回写已被锁定的缓存行的数据时，会使缓存行无效。
 * 有两种情况下处理器不会使用缓存锁定：
 * 1）当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。
 * 2）有些处理器不支持缓存锁定。
 * 3.3 Java如何实现原子操作：锁  和  循环CAS
 * 1）使用锁机制实现原子操作：锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁，
 * 和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块
 * 的时候使用循环CAS释放锁。
 * 2）使用循环CAS实现原子操作
 * JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路是循环进行CAS操作直到成功为止。
 * 3）CAS实现原子操作的三大问题
 * 1）ABA问题：CAS需要在操作值得时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，
 * 那么使用CAS检查时会发现它的值没有发生变化，但实际上却变化了。解决思路是使用版本号，1A-2B-3A。
 * 2）循环时间长开销大：自旋锁CAS如果长时间不成功，会给CPU带来非常大的执行开销。
 * 3）只能保证一个共享变量的原子操作。
 *
 * @author 郑元浩
 */
/**
 * @author 郑元浩
 *
 */
package chapter2;